rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions - Enhanced security
    function isAuthenticated() {
      return request.auth != null && request.auth.uid != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && request.auth.token.admin == true;
    }
    
    // Security validation functions
    function validateUserData() {
      return request.resource.data.keys().hasAll(['userId']) &&
             request.resource.data.userId is string &&
             request.resource.data.userId == request.auth.uid;
    }
    
    function validateStatusUpdate() {
      return !request.resource.data.diff(resource.data).affectedKeys().hasAny(['status']) ||
             (isAdmin() && request.resource.data.status in ['ממתין לאיסוף', 'בטיפול', 'נמסר', 'מבוטל']);
    }
    
    // Package requests rules - Enhanced security
    match /requests/{requestId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid || 
        resource.data.assignedTo == request.auth.uid || 
        (resource.data.keys().hasAll(['status']) && resource.data.status in ['ממתין לאיסוף', 'בטיפול']) ||
        isAdmin()
      );
      
      allow create: if isAuthenticated() && 
                       validateUserData() &&
                       request.resource.data.status == 'ממתין לאיסוף';
      
      allow update: if isAuthenticated() && (
                       (isOwner(resource.data.userId) && validateStatusUpdate()) ||
                       (resource.data.assignedTo == request.auth.uid && 
                        request.resource.data.keys().hasOnly(['status', 'updatedAt'])) ||
                       isAdmin()
                     );
      
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    // Chat rooms rules - Enhanced security
    match /chatRooms/{roomId} {
      allow read: if isAuthenticated() && 
                      (request.auth.uid in resource.data.participants || isAdmin());
      
      allow create: if isAuthenticated() && 
                       request.auth.uid in request.resource.data.participants &&
                       request.resource.data.participants.size() >= 2;
      
      allow update: if isAuthenticated() && 
                       (request.auth.uid in resource.data.participants || isAdmin()) &&
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['createdAt', 'createdBy']);
      
      allow delete: if isAdmin(); // Only admin can delete chat rooms
    }
    
    // Messages rules - Enhanced security
    match /messages/{messageId} {
      allow read: if isAuthenticated() && (
                      request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(resource.data.requestId)).data.participants ||
                      isAdmin()
                    );
      
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.senderId &&
                       request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(request.resource.data.requestId)).data.participants &&
                       request.resource.data.keys().hasAll(['senderId', 'requestId', 'content', 'timestamp']);
      
      allow update: if false; // Messages cannot be updated
      
      allow delete: if false; // Messages cannot be deleted
    }
    
    // Community alerts rules - Enhanced security
    match /communityAlerts/{alertId} {
      allow read: if isAuthenticated() && resource.data.isActive == true && resource.data.expiresAt > request.time;
      
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId','userName','userAvatar','type','community','city','message','timestamp','expiresAt','isActive']);
      
      allow update: if isOwner(resource.data.userId) || isAdmin();
      
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    // Users rules - Enhanced security
    match /users/{userId} {
      allow read: if isAuthenticated();
      
      allow create: if isAuthenticated() && 
                       request.auth.uid == userId &&
                       request.resource.data.keys().hasAll(['uid', 'email', 'createdAt']) &&
                       request.resource.data.uid == request.auth.uid;
      
      allow update: if isOwner(userId) && 
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny(['uid', 'createdAt', 'emailVerified']);
      
      allow delete: if isAdmin();
    }
    
    // Users collection - alternative pattern for testing
    match /users/{document=**} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.auth.uid == resource.data.userId;
      allow update: if isOwner(resource.data.userId) || isAdmin();
      allow delete: if isAdmin();
    }
    
    // Package tracking rules - Enhanced security
    match /packages/{packageId} {
      allow read: if isAuthenticated() && (
                      resource.data.userId == request.auth.uid || 
                      resource.data.assignedTo == request.auth.uid ||
                      resource.data.requesterId == request.auth.uid ||
                      isAdmin()
                    );
      
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId', 'trackingNumber', 'status', 'createdAt']);
      
      allow update: if isAuthenticated() && (
                       (isOwner(resource.data.userId) && validateStatusUpdate()) ||
                       (resource.data.assignedTo == request.auth.uid && 
                        request.resource.data.keys().hasOnly(['status', 'updatedAt'])) ||
                       isAdmin()
                     );
      
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    // Health check rules - for monitoring
    match /health-check/{checkId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                       request.resource.data.keys().hasAll(['timestamp', 'status', 'service']);
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }
    
    // Performance test rules - for testing
    match /performance-test/{testId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(resource.data.userId) || isAdmin();
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    // Test collection rules - for temporary testing
    match /test/{testId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(resource.data.userId) || isAdmin();
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    // Test-documents collection - for security testing
    match /test-documents/{docId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                       request.resource.data.userId == request.auth.uid;
      allow update: if isOwner(resource.data.userId) || isAdmin();
      allow delete: if isOwner(resource.data.userId) || isAdmin();
    }
    
    // Default deny all for unmatched paths
    match /{path=**} {
      allow read, write: if false;
    }
  }
}
